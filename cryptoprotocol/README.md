# Readme

All cryptographic protocols belong here. In particular, this includes Issue - Join, Credit - Earn and Spend - Deduct.

In the following you find a glossary explaining all important variables in the incentive system definition from the 2020 incentive system paper ("Cryptimeleon incentive system" in the following) which can be found at https://eprint.iacr.org/2020/382.
The variables are referenced by their name in the paper and grouped by their first occurence when traversing the algorithms/protocols in the order they are defined in the paper.
For each variable, we list its name(s) in the code and add a short and comprehensive explanation of what this variable stores/is good for.

### Setup

* BG
  * bilinear group used by algorithms of the incentive system
  * names in code: bg
* H
  * hash function used to generate group elements $w$ and $h_7$
  * in trusted setup we use: not important whether generated by third party (trusted) or generatable for everyone via hashing of constants and a well-known BG
  * so we did not implement hashing to keep the code simple
* PRF
  * PRF used to (re-)generate pseudorandomness in cryptoprotocols
  * names in code: prfToZn
* w
  * base of the user public keys (user public keys are powers of the type $w^{usk}$)
  * names in code: w
* h<sub>7</sub>
  * group element that is randomized and multiplied with the token's Pedersen commitment for sophisticated proof reasons
  * names in code: h7
* SPS-EQ
  * SPS-EQ scheme used to certify user tokens upon creation and update
  * names in code: spsEq
* g<sub>1</sub>
  * generator of G<sub>1</sub>, the first group of the used BG 
  * names in code: g1, g1Generator
* g<sub>2</sub>
  * generator of $G_2$, the second group of the used BG 
  * names in code: g2, g2Generator
* base
  * base used for ElGamal encryption secret key decomposition
  * Setup.ESK_DEC_BASE is a default value for this
  * names in code: IncentivePublicParameters.eskDecBase
* pp
  * public parameters of the Cryptimeleon incentive system
  * names in code: pp
  
### U.KeyGen
  
* usk
  * user's secret exponent
  * names in code: usk
* &#946;<sub>usr</sub>
  * PRF key that the user uses to generate pseudorandomness
  * names in code: betaUsr
* USK
  * user secret key, consisting of secret exponent and PRF key
  * names in code: uSk, usk
* upk
  * user public key (single group element)
  * note that despite the user public key is just a single group element, a data class for it exists nontheless
  * names in code: upkElem, upk
  
### P.KeyGen
  
* (pk<sub>SPS-EQ</sub>, sk<sub>SPS-EQ</sub>)
  * SPS-EQ key pair the provider uses to certify tokens
  * names in code: (pkSpsEq, skSpsEq)
* h<sub>1</sub>, ..., h<sub>6</sub>
  * bases used in the token's Pedersen commitment
  * are represented in the code as a single vector
  * names in code: h
* q<sub>1</sub>, ..., q<sub>6</sub>
  * DLOGs of the bases used in the token's Pedersen commitment
  * are represented in the code as a single vector
  * names in code: q
* &#946;<sub>prov</sub>
  * PRF key that the provider uses to generate pseudorandomness
  * names in code: betaProv
* sk
  * provider secret key
  * names in code: sk
* pk
  * provider public key
  * names in code: pk
  
### Issue-Join

* esk<sup>*</sup><sub>usr</sub>
  * fresh Zp exponent used for updating/initializing a token
  * represents the user share of the ElGamal encryption secret key used in tracing double spending attempts
  * names in code: eskUsr
* dsrnd<sup>*</sup><sub>0</sub>
  * fresh Zp exponent used for updating/initializing a token
  * randomness used for generating the challenge 0 associated with a spend operation
  * used in double-spending protection
  * names in code: dsrnd0
* dsrnd<sub>1</sub>
  * fresh Zp exponent used for updating/initializing a token
  * randomness used for generating the challenge 1 associated with a spend operation
  * used in double-spending protection
  * names in code: dsrnd1
* z<sup>*</sup>
  * fresh Zp exponent used for updating/initializing a token 
  * first value used to blind the token Pedersen commitment
  * names in code: z
* t<sup>*</sup>
  * fresh Zp exponent used for updating/initializing a token 
  * second value used to blind the token Pedersen commitment
  * needed for sophisticated proof reasons
  * names in code: t
* u<sup>*</sup>
  * fresh Zp exponent used for updating/initializing a token 
  * used to blind entire group element vector in token by computing different representative
  * names in code: u
* C<sup>(pre)</sup>
  * "preliminary commitment", "pre-commitment"
  * (uncertified) group element vector that is sent to the provider for certification upon token creation and update
  * consists of two components: a triple-blinded Pedersen commitment C<sub>0</sub><sup>(pre)</sup> and a randomization C<sub>1</sub><sup>(pre)</sup> of the generator of group G<sub>1</sub> from the pp (randomized)
  * names in code: cPre
* C<sub>0</sub><sup>(pre)</sup>
  * first component of the pre-commitment C<sup>(pre)</sup>
  * names in code: c0Pre, preCommitment0
* C<sub>1</sub><sup>(pre)</sup>
  * second component of the pre-commitment C<sup>(pre)</sup>
  * names in code: c1Pre, preCommitment1
* esk<sup>*</sup><sub>prov</sub>
  * represents the provider share of the ElGamal encryption secret key used in tracing double-spending attempts
  * names in code: eskProv
* &#963;
  * certificate for the preliminary token commitment
  * generated by provider to answer user query
  * names in code: cert, preCert
* C<sup>*</sup>
  * final commitment at the end of the token generation process
  * part of the user token 
  * names in code: none (does not appear as an entity)
* &#963;<sup>*</sup>
  * certificate for the commitment in the final token
  * adapted version of the pre-certificate &#963;
  * names in code: finalCert
* esk<sup>*</sup>
  * ElGamal encryption secret key used in tracing double-spending attempts
  * computed by adding up user and provider shares
  * names in code: esk
* dsid<sup>*</sup>
  * double-spending ID associated with the token generated in a particular Issue-Join run
  * used to identify the token in double-spending protection
  * redundant information: can be computed from a token (contains esk) and the public parameters (contain w, note dsid<sup>*</sup> = w<sup>esk</sup>) 
  * names in code: none (not implemented because of above reason)

### Credit-Earn

* k
  * amount of points earned in a specific Credit-Earn execution
  * names in code: k
* s
  * blinding randomness used to blind existing token commitment + its certificate when submitting them to provider in earn request
  * names in code: s
* C'
  * blinded token commitment
  * names in code: not stored in a variable but computed on the fly, thus not named
* &#963;'
  * blinded token's certificate
  * names in code: not stored in a variable but computed on the fly, thus not named
* &#963;''
  * updated blinded token's certificate
  * names in code: not stored in a variable but computed on the fly, thus not named
* C<sup>*</sup>
  * final un-blinded updated token commitment
  * names in code: not stored in a variable but computed on the fly, thus not named
* &#963;<sup>*</sup>
  * final un-blinded updated token certificate
  * names in code: not stored in a variable but computed on the fly, thus not named

Note: all secret exponents contained in the updated token are computed on the fly as well and thus not named in code

### Spend-Deduct

* &#947;
  * used in generation of challenges c<sub>0</sub>, c<sub>1</sub> needed in double-spending detection
  * derived from preliminary updated token commitment, spend amount and transaction metadata (transaction ID, used token's double spending ID)
  * names in code: gamma
* c<sub>0</sub>
  * first challenge needed in the Schnorr-trick for double-spending protection
  * generated using double-spending randomness dsrnd<sub>0</sub>, user secret key usk and exponent
  * together with another challenge using the same usk, a double-spending user's usk can be revealed
  * names in code: c0
* c<sub>1</sub>
  * second challenge needed in the Schnorr-trick for double-spending protection
  * generated using double-spending randomness dsrnd<sub>1</sub>, ElGamal encryption secret key esk and exponent
  * together with another challenge using the same esk, the encryption secret key esk for tracing a double-spending user's further transactions can be revealed
  * names in code: c1
* r<sub>1</sub>, ..., r<sub>&#961;</sub>
  * encryption randomness for the ElGamal encryption of the powers of the digits of the user share of the ElGamal encryption key for the next token
  * next token means the outcome of the respective Spend operation
  * r<sub>i</sub> are represented as a single vector in the code
  * names in code: vectorR
* ctrace
  * vector of the ElGamal-encrypted powers of the digits of the user share of the ElGamal encryption key for the next token
  * next token again means the outcome of the respective Spend operation
  * by definition of ElGamal, ctrace thus is a vector of 2-tuples
  * to simplify the code using craco's vector operation, ctrace was refactored into two vectors (the 0-vector contains all 0-components, the 1-vector containing all 1-components)
  * names in code: cTrace0 (vector of 0-components), cTrace1 (vector of 1-components)
* dstag
  * data which the provider requires to trace double-spending
  * associated to a spend operation
  * consists of
    * challenges c<sub>0</sub>, c<sub>1</sub> the user generated
    * challenge generation exponent &#947;
    * digit-wise ElGamal encrypted user share of next encryption secret key
    * plaintext provider share of next encryption secret key
  * names in code: dsTag
